# Operating System

### ⚡️ Chapter 1-2. Introduction & OS Stuructures

- 운영체제란 무엇인가?
  > 컴퓨터 하드웨어를 관리하는 소프트웨어이자 컴퓨터에서 항상 실행 중인 프로그램이다. 응용 프로그램을 위한 기반(system service)을 제공하며, 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 하면서 사용자가 하드웨어를 직접 조작하는 것을 방지한다. 

- 운영체제의 주요 목적은?
  > 다양한 사용자를 위해 다양한 응용 프로그램 간의 하드웨어 사용을 제어하고 조정한다. 이를 통해 사용자 편의성과 시스템 효율성을 높이는 것을 목적으로 한다.

- 커널이란 무엇인가?
  > 운영체제의 핵심 기능을 의미한다. 운영체제 자체도 소프트웨어이므로 컴퓨터 시스템에서 수행되기 위해선 메모리에 프로그램이 올라가 있어야 한다. 하지만 운영체제는 규모가 매우 크기 때문에 모두 메모리에 올라간다면 메모리 공간의 낭비가 발생할 수 있으므로, 항상 필요한 부분만을 메모리에 올려놓고 사용하게 된다. 이때 메모리에 상주하는 운영체제의 부분을 커널이라고 한다.

- 부팅이 되는 과정은?
  > 컴퓨터의 전원이 켜지면 Boot-ROM에 저장되어 있는 Bootstrap Program이 실행된다.  
  > 1. Bootstrap Program은 가장 먼저 CPU 레지스터, 메모리 등 컴퓨터 시스템 하드웨어를 초기화한다. 
  > 2. 하드 디스크 드라이브에서 운영체제 프로그램을 메인 메모리의 첫 번째 주소 위치에 로드한 후, PC 레지스터에 해당 주소를 저장한다. 
  > 3. 운영체제 프로그램 실행이 시작된다. 

- 시스템 콜에 대해 설명하세요
  > 사용자(응용프로그램)가 운영체제(커널)의 서비스를 사용할 수 있도록 하는 인터페이스이다. 특정 저수준 작업은 어셈블리 언어로, 대부분은 C, C++ 같은 HLL로 작성된 함수 형태로 제공된다.  
  > 시스템 콜의 종류는 크게 프로세스 제어, 파일 조작, 장치 조작, 정보 유지 보수, 커뮤니케이션, 보안으로 묶인다. 

- 멀티프로세싱과 멀티프로그래밍의 차이는?
  > * __멀티프로세싱__ : 다수의 프로세서(CPU)가 다수의 프로세스를 서로 협력적으로 처리하는 것, 프로그램을 더 빨리 처리하기 위함이 목적
  > * __멀티프로그래밍__ : 단일 프로세서(CPU)가 다수의 프로세스가 동시에 처리하는 것, CPU의 활용도를 최대화하기 위함이 목적

- 메모리 계층 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오.
  > 레지스터 - 캐시 - 메인 메모리 - 비휘발성 메모리 - 하드 디스크 드라이브 - 광학 디스크 - 자기 테이프 순이다.  

----------------------------------------------------------------------------------------------------------------
  
### ⚡️ Chapter 3. Processes

- Heap과 Stack의 차이점은 무엇인가요?
  > * __Heap__ : FIFO, 프로그램의 런타임 중에 동적으로 할당되는 메모리가 저장되는 영역이다.  
  > * __Stack__ : LIFO, 함수 호출 시 함수 파라미터, return 주소, 지역 변수 등 임시 데이터의 저장장소이다. 

- 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요.
  > * __Text__ : Code 혹은 Instruction 영역이라고도 하며, 프로그램 코드가 저장되어 있다. 고정 크기이다.
  > * __Data__ : 전역 변수를 저장하고 있는 영역이다. 고정 크기이다.
  > * __Heap__ : 프로그램의 런타임 중에 동적으로 할당되는 메모리가 저장되는 영역이다. 가변 크기이다.
  > * __Stack__ : 함수 호출 시 함수 파라미터, return 주소, 지역 변수 등 임시 데이터의 저장장소이다. 가변 크기이다.

- 프로세스와 그 특징에 대해 설명하세요
  > 프로세스란 쉽게 말해 실행 중인 프로그램이며 CPU의 모든 활동을 말한다. 운영체제 내의 작업의 단위이다.   
  > 프로세스는 메모리 내에 여러 구역으로 구성되어 배치된다. Text 영역에는 프로그램의 코드, Data 영역에는 전역/static 변수, Heap 영역에는 프로그램 런타임 중 동적으로 할당되는 메모리, Stack 영역에는 함수 호출 시의 임시 데이터가 저장된다.  
  > 프로세스는 실행되는 동안 여러 상태를 가지며 변화한다. New는 프로세스가 생성 중일 때, Running은 명령어들이 실행 중일 때, Waiting은 특정 이벤트가 발생하기를 기다릴 때, Ready는 프로세서가 할당되기를 기다릴 때, Terminated는 실행이 종료되었을 때의 상태를 말한다. 

- 프로세스가 종료되는 두 가지 조건은?
  > - 첫 번째는 프로세스가 마지막 문장의 실행을 끝내고, exit() 시스템 콜을 사용하여 OS에 자신의 삭제를 요청하여 종료한다. 이때 프로세스는 자신을 기다리는 부모 프로세스의 wait() 호출에 의해 상태 값을 반환하고, 물리 메모리, 가상 메모리, 열린 파일, 입출력 버퍼 등의 모든 자원을 OS에 반환한다.  
  > - 두 번째는 부모 프로세스가 자식 프로세스를 종료시키는 것이다. 부모 프로세스가 자식의 pid 값을 이용해 적절한 시스템 콜을 호출하여 자식 프로세스의 종료를 유발할 수 있다. 이때 부모 프로세스만이 이러한 시스템 콜을 호출할 수 있다.

- 인터럽트 발생 처리과정을 설명하세요.
  > CPU가 컨트롤러가 인터럽트 요청 라인에 신호를 보낸 것을 감지하면, 현재 실행 중인 현재 모든 레지스터 내용을 스택 영역 혹은 PCB에 저장한다.  
  > 그 후 인터럽트 번호를 읽고 해당 번호를 인터럽트 벡터의 인덱스로 사용하여 인터럽트 서비스 루틴(ISR)로 점프하고 인터럽트를 처리한다.  
  > 인터럽트 서비스 루틴의 실행이 종료되면, 저장해놓았던 레지스터 내용을 다시 복구하여 중단됐던 프로그램을 이어서 실행한다. 

- 인터럽트 기능이 없었다면 사용하는 방식에 대해 설명하세요.
  > 인터럽트 기능이 없었다면 컨트롤러는 어떤 일을 할 때를 알기 위해 계속 체크해야 하며, 이를 **폴링(Polling)** 이라고 한다. 폴링은 CPU가 다른 프로그램이나 입출력 장치들에서의 상태 변화를 지속적으로 계속 확인하고 그에 따라 프로그램을 처리하는 방식이다. 인터럽트 방식에 비해 구현이 간편하다는 장점이 있지만 다른 프로그램이나 장치들 간의 폴링이 많아질수록 CPU 사용량이 늘어나 성능이 크게 떨어지게 되며, 폴링의 주기가 길어질수록 반응 속도가 늦어져 실시간성이 떨어진다는 단점이 있다.

- 프로세스의 생성 과정에 대해 설명해보세요.
  > 1. 생성된 새로운 프로세스에 프로세스 id를 할당한다.  
  > 2. 프로세스의 모든 구성 요소를 포함할 수 있는 주소 공간과 PCB 공간을 할당한다.  
  > 3. PCB를 초기화한다. 프로그램의 코드는 Text 영역, 초기화된 전역/static 변수는 Data 영역에 저장되며 Heap과 Stack 영역은 초기 메모리 주소만 초기화된다. 그 외에 프로세스의 상태 정보, 프로그램 카운터, 우선순위 등이 초기화된다.
  > 4. PCB에 여러 정보가 기록되면 Ready Queue에서 CPU를 할당받기를 대기한다. 

- IPC의 통신 과정 설명하세요.
  > IPC의 방식에는 Shared Memory 방식과 Message Passing 방식 두 가지가 있다.  
  > **Shared Memory** 방식은 둘 이상의 프로세스가 공유하는 메모리 영역을 두고 해당 메모리 영역에 데이터를 채우거나 소비하는 등 변경하는 데이터를 공유하는 방식으로 통신한다.  
  > **Message Passing** 방식은 두 프로세스가 communication link를 설정하고 서로 메시지를 주고받는 방식으로 통신하며, 이때 커널이 메시지를 전달해주며 관리한다.

- Context Switching이란 무엇인가요?
  > CPU가 인터럽트 요청에 의해 현재 실행 중인 Task(프로세스 또는 스레드)을 멈추고 다른 Task를 실행해야 할 때, 현재 진행하고 있는 Task의 상태를 PCB 또는 TCB에 저장하고 다음으로 진행할 Task를 실행할 수 있도록 상태 값을 읽어와 저장하는 교체 과정을 말한다. 

- 동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?
  > Message passing 시스템에서 두 프로세스가 서로 메시지를 주고받기 위해 설정되어야 할 통신연결(communication link) 방법의 종류들이다.   
  > __동기식(synchronous)과 블로킹(Blocking)은 같은 방법을 의미하는 것이다.__ 이 방법에서 메시지 송신 시 송신자는 메시지가 수신자 혹은 메일박스에 의해 수신될 때까지 봉쇄되고, 수신 시 수신자는 메시지가 이용 가능해질 때까지 봉쇄된다.  
  > __비동기식(asynchronous)과 넌블로킹(Non-blocking)은 같은 방법을 의미하는 것이다.__ 이 방법에서 메시지 송신 시 송신자는 메시지 수신 여부에 관계없이 메시지 전송 후 작업을 이어서 하게 되고, 수신 시 수신자는 메시지 이용 가능 여부에 관계없이 유효한 메시지 또는 널(null)메시지를 수신한다.

- 프로세스 제어블록에는 어떤 정보가 담겨있나요?
  > * **Process number** : 프로세스 id (pid)
  > * **Process state** : new / ready / running / waiting / terminate / halted 등 프로세스의 상태
  > * **Program counter** : process가 다음으로 실행할 instruction의 주소
  > * **CPU registers** : AC, IR, DR, SR, General-purpose register, condition code 등의 레지스터 정보  
  > * **CPU-scheduling information** : process 우선순위, scheduling queue의 포인터 등
  > * **Memory-management information** : base/limit register의 값, page table/segment table 정보 등 
  > * **Accounting information** : CPU 사용 시간, 계정번호 등 
  > * **I/O State information** : 열린 파일들의 리스트, 이 process에 할당된 I/O 장치들

- child process, orphan process, zombie process에 대해 설명해 보시오.
  > * __child process__ : 어떤 process에서 fork() 시스템 콜을 호출하여 새롭게 생성된 process를 의미, 이때 fork()를 호출한 process는 parent process라고 한다.  
  > * __orphan process__ : 자식 프로세스가 exit() 시스템 콜을 호출하여 종료되면 사용하던 자원과 메모리는 운영체제로 반환되지만 프로세스 id와 프로세스 종료 상태 등의 정보가 프로세스 테이블에 남아있게 되는데, parent process에서 wait() 시스템 콜을 호출함으로써 자식 프로세서의 종료 상태를 회수하면 남아있던 정보까지 운영체제로 반환된다. 그러나 parent process가 wait()을 호출하지 않고 자식 프로세스보다 먼저 종료해버린 경우에 child process가 완전히 종료되지 못하고 남아있게 되는데 이때 child process를 orphan process라고 한다. UNIX 시스템에선 이 상태를 orphan process의 parent를 모든 process의 상위 프로세스인 init process로 설정하고 wait()를 호출함으로써 해결한다.  
  > * __zombie process__ : 자신은 종료되었지만, parent prcess가 아직 wait()를 호출하지 않은 상태일 때의 child process를 의미한다. 모든 프로세스는 아주 짧은 시간이나마 zombie process 상태를 머무르게 된다. zombie process를 활용하여 daemon process(background process)를 만들 때 쓰이기도 한다. 
