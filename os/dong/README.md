### **⚡️ Chapter 1-2. Introduction & OS Structures**

- 운영체제란 무엇인가?
    
    컴퓨터 시스템(하드웨어)을 운영 및 관리하는 항상 실행 중인 시스템 소프트웨어(프로그램)이다. 
    
    + 운영체제의 하는 일 : 프로세스 및 자원을 관리하고 프로그램을 제어하는 역할을 한다.
    
- 운영체제의 주요 목적은?
    
    사용자가 시스템을 빠르고 편리하게 사용할 수 있도록 하고, 공정하고 효과적으로 자원을 관리하는 것이 목적이다. 
    
- 커널이란 무엇인가?
    
    OS의 핵심적인 부분으로, 컴퓨터 하드웨어와 사용자 프로세스를 잇는 핵심 인터페이스로 메모리에 상주하며 메모리, 프로세스 관리, 디바이스 제어, 시스템 콜과 보안를 관리하는 역할을 한다.  
    
- 부팅이 되는 과정은?
    
    Boot-ROM(비휘발성 메모리)에 저장되어 있는 Bootstrap Program을 실행(메모리에 로드된 OS 프로그램의 첫번째 주소를 PC에 저장하고, fetch, decode, … , store)하면서 부팅이 된다. 
    
    Bootstrap Program은 컴퓨터 시스템 하드웨어(CPU register, device controller, memory contents 등)를 초기화하고, HDD에서 OS 프로그램을 MM의 첫번째 자리에 로드하여 OS를 실행한다. 
    
- 시스템 콜에 대해 설명하세요
    
    User와 Kernel 사이의 인터페이스로 User가 OS service를 활용하도록 돕는다. 예로 open, close, read, write 등 라이브러리(함수)가 있다.  
    
- 멀티 프로세싱과 멀티프로그래밍의 차이는?
    
    멀티 프로그래밍은 동시에 한 개 이상의 프로그램을 실행시킨다는 의미로 메모리에 여러 개의 프로세스가 존재하는 것이고, 멀티 프로세싱은 멀티 프로그래밍의 논리적인 확장으로 CPU가 여러 개인 시스템에서 동시에 여러 개의 작업(프로세스)들을 실행한다는 것이다. 
    
- 메모리 계층 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오.
    
    register → cache → main memory → solid-state-disk(SSD) → hard disk(HDD) → optical disk → magnetic tapes
    

### **⚡️ Chapter 3. Processes**

- Heap과 Stack의 차이점은 무엇인가요?
    
    Heap영역에는 프로그램 실행 시간 중 동적할당되는 메모리가 저장되고, Stack영역에는 함수 실행 시 일시적인 데이터, 함수의 매개변수, 반환값, 지역변수의 저장소로 쓰인다. 
    
- 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요.
    
    메모리 영역은 text, data, heap, stack 4가지 영역으로 나눠진다. 
    
    text 영역에는 실행 코드가 저장된다. 
    
    data 영역에는 전역 변수가 저장된다. 
    
    heap 영역에는 프로그램의 실행 시간 중에 동적할당되는 메모리가 저장된다.
    
    stack 영역에는 함수의 매개변수, 반환값, 지역 변수와 같은 함수 실행 시 생기는 일시적인 데이터가 저장된다. 
    
- 프로세스와 그 특징에 대해 설명하세요
    
    프로세스는 실행 중인 프로그램으로 운영체제에서 작업의 단위이다. 
    
    프로세스는 5가지의 영역(header, text, stack, data, heap)으로 구분된다. 
    
    프로세스는 6가지 상태 (New, Running, Waiting, Ready, Zombie, Terminated) 를 가진다. 
    
    각 프로세스의 정보는 PCB에 저장된다. 
    
- 프로세스의 생성 과정에 대해 설명해보세요.
    
    리눅스에서는 fork()라는 시스템 콜에 의해서 프로세스가 생성된다. fork()가 실행되면 커널은 부모 프로세스를 복제한 자식 프로세스를 생성한다. (모든 변수들이 동일하지만 독립적이다.) 
    
- 프로세스가 종료되는 두 가지 조건은?
    
    프로세스가 마지막 명령을 수행하거나 exit() 시스템 콜을 호출하였을 때 스스로 종료한다. 
    
    프로세스가 다른 프로세스를 종료시키는 경우에는 abort() 또는 kill(pid) 스스템 콜을 호출하며, 자식 프로세스가 할당된 자원 사용량을 초과한 경우와 자식 프로세스가 더 이상 필요 없는 경우와 부모 프로세스가 종료되는 경우가 있다. 
    
- 프로세스 제어블록에는 어떤 정보가 담겨있나요?
    
    PCB에는 프로세스의 모든 정보를 담고 있는 구조체로 pid, 상태, PC, CPU 레지스터, CPU 스케줄링, 메모리 관리, 계좌, I/O 상태에 대한 정보들이 담겨있다. 
    
- child process, orphan process, zombie process에 대해 설명해 보시오.
    
    자식 프로세스는 부모 프로세스가 fork() 시스템 콜을 호출하면서 만들어진 프로세스로 부모의 프로세스의 복제 프로세스이다. 
    
    고아 프로세스는 부모 프로세스가 종료된 프로세스를 의미한다. 
    
    좀비 프로세스는 소멸된 프로세스이지만 메모리 상에 정보가 남아있는 프로세스로, 부모 프로세스가 wait를 호출하지 않은 프로세스이다. 
    
- 인터럽트 발생 처리과정을 설명하세요.
    
    인터럽트 신호가 CPU에 도착하면 OS는 PC를 저장하고, CPU는 인터럽트의 타입을 ISR의 시작주소를 얻기 위해 인터럽트 벡터를 확인한다. 적절한 ISR를 실행한 후, CPU는 다시 그 전의 프로세스를 실행한다. 
    
- 인터럽트 기능이 없었다면 사용하는 방식에 대해 설명하세요.
    
    폴링이라는 방법으로 디바이스가 같은 신호를 가지고 CPU에게 서비스가 필요하다고 알리는 것이다. CPU는 신호를 받으면 모든 디바이스들을 확인한다. 
    
- Context Switching이란 무엇인가요?
    
    CPU가 실행 중인 프로세스를 전환하는 것이다. (context는 PCB에 저장됨)
    
    인터럽트가 발생하면 시스템은 실행 중인 프로세스의 현재 context를 저장하고 다른 프로세스로 전환한다. 현재 프로세스의 상태를 저장하기 때문에 나중에 다시 시작할 때 context를 복원할 수 있다. 
    
- IPC의 통신 과정 설명하세요.
    
    IPC는 프로세스들이 소통하고 동기화할 수 있도록 하는 방법을 의미한다. 
    
    IPC는 크게 공유 메모리와 메시지 패싱 방법이 있다. 
    
    공유 메모리의 경우, 프로세스 간의 통신 채널로 공유 메모리 공간을 사용한다. OS는 프로세스에게 공유 메모리 공간에 접근할 수 있는 권한을 준다. (공유 메모리의 예시로 Producer-Consumer 문제가 있는데 공유 버퍼를 사용하여 Producer는 버퍼가 비어있다면 채우고, consumer는 버퍼가 채워져있다면 비운다. )
    
    메시지 패싱의 경우, 메시지를 보내고 받는 2가지 기능을 제공한다. 
    
    direct 통신은 수신인과 발신인을 명시하고 소통하는 두 프로세스 사이에 자동으로 하나의 링크가 생성된다. 
    
    indirect 통신은 수신인과 발신인을 명시하지 않아도 되고, 메시지들을 mailbox나 port를 통해서 주고 받는다. 각 프로세스가 공유 mailbox를 가지고 있는 경우 링크가 생성되고, 링크는 2개 이상의 프로세스와 연결될 수 있다. 
    
- 동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?
