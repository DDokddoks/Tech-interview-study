### **⚡️ Chapter 1-2. Introduction & OS Structures**

- 운영체제란 무엇인가?
    
    컴퓨터 시스템(하드웨어)을 운영 및 관리하는 항상 실행 중인 시스템 소프트웨어(프로그램)이다. 
    
    + 운영체제의 하는 일 : 프로세스 및 자원을 관리하고 프로그램을 제어하는 역할을 한다.
    
- 운영체제의 주요 목적은?
    
    사용자가 시스템을 빠르고 편리하게 사용할 수 있도록 하고, 공정하고 효과적으로 자원을 관리하는 것이 목적이다. 
    
- 커널이란 무엇인가?
    
    OS의 핵심적인 부분으로, 컴퓨터 하드웨어와 사용자 프로세스를 잇는 핵심 인터페이스로 메모리에 상주하며 메모리, 프로세스 관리, 디바이스 제어, 시스템 콜과 보안를 관리하는 역할을 한다.  
    
- 부팅이 되는 과정은?
    
    Boot-ROM(비휘발성 메모리)에 저장되어 있는 Bootstrap Program을 실행(메모리에 로드된 OS 프로그램의 첫번째 주소를 PC에 저장하고, fetch, decode, … , store)하면서 부팅이 된다. 
    
    Bootstrap Program은 컴퓨터 시스템 하드웨어(CPU register, device controller, memory contents 등)를 초기화하고, HDD에서 OS 프로그램을 MM의 첫번째 자리에 로드하여 OS를 실행한다. 
    
- 시스템 콜에 대해 설명하세요
    
    User와 Kernel 사이의 인터페이스로 User가 OS service를 활용하도록 돕는다. 예로 open, close, read, write 등 라이브러리(함수)가 있다.  
    
- 멀티 프로세싱과 멀티프로그래밍의 차이는?
    
    멀티 프로그래밍은 동시에 한 개 이상의 프로그램을 실행시킨다는 의미로 메모리에 여러 개의 프로세스가 존재하는 것이고, 멀티 프로세싱은 멀티 프로그래밍의 논리적인 확장으로 CPU가 여러 개인 시스템에서 동시에 여러 개의 작업(프로세스)들을 실행한다는 것이다. 
    
- 메모리 계층 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오.
    
    register → cache → main memory → solid-state-disk(SSD) → hard disk(HDD) → optical disk → magnetic tapes
    

### **⚡️ Chapter 3. Processes**

- Heap과 Stack의 차이점은 무엇인가요?
    
    Heap영역에는 프로그램 실행 시간 중 동적할당되는 메모리가 저장되고, Stack영역에는 함수 실행 시 일시적인 데이터, 함수의 매개변수, 반환값, 지역변수의 저장소로 쓰인다. 
    
- 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요.
    
    메모리 영역은 text, data, heap, stack 4가지 영역으로 나눠진다. 
    
    text 영역에는 실행 코드가 저장된다. 
    
    data 영역에는 전역 변수가 저장된다. 
    
    heap 영역에는 프로그램의 실행 시간 중에 동적할당되는 메모리가 저장된다.
    
    stack 영역에는 함수의 매개변수, 반환값, 지역 변수와 같은 함수 실행 시 생기는 일시적인 데이터가 저장된다. 
    
- 프로세스와 그 특징에 대해 설명하세요
    
    프로세스는 실행 중인 프로그램으로 운영체제에서 작업의 단위이다. 
    
    프로세스는 5가지의 영역(header, text, stack, data, heap)으로 구분된다. 
    
    프로세스는 6가지 상태 (New, Running, Waiting, Ready, Zombie, Terminated) 를 가진다. 
    
    각 프로세스의 정보는 PCB에 저장된다. 
    
- 프로세스의 생성 과정에 대해 설명해보세요.
    
    리눅스에서는 fork()라는 시스템 콜에 의해서 프로세스가 생성된다. fork()가 실행되면 커널은 부모 프로세스를 복제한 자식 프로세스를 생성한다. (모든 변수들이 동일하지만 독립적이다.) 
    
- 프로세스가 종료되는 두 가지 조건은?
    
    프로세스가 마지막 명령을 수행하거나 exit() 시스템 콜을 호출하였을 때 스스로 종료한다. 
    
    프로세스가 다른 프로세스를 종료시키는 경우에는 abort() 또는 kill(pid) 스스템 콜을 호출하며, 자식 프로세스가 할당된 자원 사용량을 초과한 경우와 자식 프로세스가 더 이상 필요 없는 경우와 부모 프로세스가 종료되는 경우가 있다. 
    
- 프로세스 제어블록에는 어떤 정보가 담겨있나요?
    
    PCB에는 프로세스의 모든 정보를 담고 있는 구조체로 pid, 상태, PC, CPU 레지스터, CPU 스케줄링, 메모리 관리, 계좌, I/O 상태에 대한 정보들이 담겨있다. 
    
- child process, orphan process, zombie process에 대해 설명해 보시오.
    
    자식 프로세스는 부모 프로세스가 fork() 시스템 콜을 호출하면서 만들어진 프로세스로 부모의 프로세스의 복제 프로세스이다. 
    
    고아 프로세스는 부모 프로세스가 종료된 프로세스를 의미한다. 
    
    좀비 프로세스는 소멸된 프로세스이지만 메모리 상에 정보가 남아있는 프로세스로, 부모 프로세스가 wait를 호출하지 않은 프로세스이다. 
    
- 인터럽트 발생 처리과정을 설명하세요.
    
    인터럽트 신호가 CPU에 도착하면 OS는 PC를 저장하고, CPU는 인터럽트의 타입을 ISR의 시작주소를 얻기 위해 인터럽트 벡터를 확인한다. 적절한 ISR를 실행한 후, CPU는 다시 그 전의 프로세스를 실행한다. 
    
- 인터럽트 기능이 없었다면 사용하는 방식에 대해 설명하세요.
    
    폴링이라는 방법으로 디바이스가 같은 신호를 가지고 CPU에게 서비스가 필요하다고 알리는 것이다. CPU는 신호를 받으면 모든 디바이스들을 확인한다. 
    
- Context Switching이란 무엇인가요?
    
    CPU가 실행 중인 프로세스를 전환하는 것이다. (context는 PCB에 저장됨)
    
    인터럽트가 발생하면 시스템은 실행 중인 프로세스의 현재 context를 저장하고 다른 프로세스로 전환한다. 현재 프로세스의 상태를 저장하기 때문에 나중에 다시 시작할 때 context를 복원할 수 있다. 
    
- IPC의 통신 과정 설명하세요.
    
    IPC는 프로세스들이 소통하고 동기화할 수 있도록 하는 방법을 의미한다. 
    
    IPC는 크게 공유 메모리와 메시지 패싱 방법이 있다. 
    
    공유 메모리의 경우, 프로세스 간의 통신 채널로 공유 메모리 공간을 사용한다. OS는 프로세스에게 공유 메모리 공간에 접근할 수 있는 권한을 준다. (공유 메모리의 예시로 Producer-Consumer 문제가 있는데 공유 버퍼를 사용하여 Producer는 버퍼가 비어있다면 채우고, consumer는 버퍼가 채워져있다면 비운다. )
    
    메시지 패싱의 경우, 메시지를 보내고 받는 2가지 기능을 제공한다. 
    
    direct 통신은 수신인과 발신인을 명시하고 소통하는 두 프로세스 사이에 자동으로 하나의 링크가 생성된다. 
    
    indirect 통신은 수신인과 발신인을 명시하지 않아도 되고, 메시지들을 mailbox나 port를 통해서 주고 받는다. 각 프로세스가 공유 mailbox를 가지고 있는 경우 링크가 생성되고, 링크는 2개 이상의 프로세스와 연결될 수 있다. 
    
- 동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?


### ⚡️ Chapter 4. Thread

- 프로세스와 쓰레드의 차이를 설명해보세요

  > 프로세스는 운영체제로부터 할당받는 작업의 단위(실행 중인 프로그램)이고, 스레드는 할당 받은 자원을 이용하는 실행 단위이다. 프로세스는 독립적인 메모리 영역을 할당받지만 스레드는 스택을 제외한 나머지 공간을 공유한다.

- 크롬 탭이 프로세스인지 쓰레드인지 설명해보세요

  > 크롬은 탭마다 PID를 가지고 있으니 Process이며 각 Tab마다 랜더링 정보나 기타 데이터를 따로 관리한다. 이로 인해 메모리를 많이 잡아먹기도 하지만 하나의 Tab에 오류가 생겼다고 모든 Tab에 영향을 끼치진 않는다.

- 멀티 프로세스와 멀티 스레드 각각의 장단점

  > - 멀티 프로세스
  >   - 장점  
  >     • 각 프로세스가 독립된 영역(code, data, stack, heap)을 갖고 있기 때문에 여러 자식 프로세스 중 하나에 문제가 발생해도 해당 프로세스에만 영향을 미친다.  
• 메모리 침범 문제를 OS 차원에서 해결하므로 안전하다.  
  >   - 단점  
  >      • 작업량이 많아지면 context switching 시 오버헤드가 발생한다.  
          • 프로세스 간의 복잡한 통신(IPC)가 필요하다.  
  > - 멀티 스레드
  >   - 장점  
  >     • 메모리 공간, 시스템 자원의 효율성이 증가한다.  
• context switching 시 교환해야 할 대상이 적으므로 비용이 적다.  
• data, heap 영역을 이용해 데이터를 주고 받으므로 스레드 간 통신이 간단하다.  
  >   - 단점  
  >     • 서로 다른 스레드가 Stack을 제외한 메모리 공간을 공유하기 때문에 동기화 문제가 발생할 수 있다.  
• 스레드 간의 자원 공유는 전역 변수(data segment)를 이용하므로 다른 스레드가 동시에 사용할 때 충돌이 발생할 수 있다.  
• 하나의 스레드에 문제가 생기면 전체 스레드가 영향을 받는다.  
• 주의 깊은 설계가 필요하며 디버깅이 까다롭다.  
• 멀티 스레드의 단점은 critical section 기법을 통해 대비할 수 있다.  

- 멀티 프로세스 대신 멀티 스레드를 사용하는 이유는 무엇입니까?

  > - Responsiveness(응답성)
  >    - 프로세스의 일부가 block 되어도, 지속적인 실행이 가능함
  >  - Resource Sharing(자원 공유)
  >    - 프로세스의 자원을 공유하여 shared memory와 message passing보다 용이
  >  - Economy(경제)
  >    - 프로세스 생성보다 효율적
  >    - 스레드 스위칭이 context switching보다 오버헤드가 적음
  >  - Scalability(확장성)
  >     - 각 프로세스들을 thread 단위로 분할하여 실행함으로써 multiprocessor 구조에서 더 큰 이점을 얻을 수 있음

- 사용자 수준의 스레드와 커널 수준의 스레드의 차이는 무엇인가요?

  > - **User threads**
  >   - user mode에서 사용되는 thread  
  >   - kernel 위에서 kernel support 없이 관리  
  >   - OS가 가진 CPU들을 자유롭게 사용할 수는 없음  
  > - **kernel threads**
  >   - kernel mode에서 사용되는 thread  
  >   - OS가 직접 관리 및 지원  
  >   - OS가 가진 CPU들을 자유롭게 사용할 수 있음  

- 스레드 풀링이란 무엇이고 장점은?

  > - Thread Pools
  >   - 프로세스를 시작할 때 아예 일정한 수의 thread들을 미리 풀로 만들어 두는 것  
  >   - 매번 사용되고 바로 폐기되는 스레드를 새로 생성하는 것은 시간 낭비  
  >   - 개수의 한계 없이 모든 요청에서 새 스레드를 생성하면 CPU 시간, 메모리 공간 등 자원이 고갈될 수 있기 때문  
  > - 장점
  >   - 새 스레드를 만들어 주기보다 기존 스레드로 서비스해 주는 것이 종종 더 빠르다.  
  >   - 스레드 풀은 임의 시각에 존재할 스레드 개수에 제한을 둔다. 이러한 제한은 많은 수의 스레드를 병렬 처리할 수 없는 시스템에 도움이 된다.  
  >   - 태스크를 생성하는 방법을 태스크로부터 분리하면 태스크를 실행을 다르게 할 수 있다. 예를 들어 태스크를 일정 시간 후에 실행되도록 스케줄 하거나 혹은 주기적으로 실행시킬 수 있다.  
  
### ⚡️ Chapter 5. CPU Scheduling
 
- CPU 스케줄링이란 무엇인가요?  
  > CPU 스케줄러사 Ready queue에 있는 프로세스 중에서 어떤 프로세스에게 CPU를 할당할지 결정하는 것 (운영체제 내의 기능을 하는 코드)

- CPU Scheduling은 언제 발생하는가? 
  >- Running → Blocked (Non-preemptive) : 실행 중이다가 I/O 작업을 하러 간 경우
  >- Running → Ready (Preemptive) : 인터럽트로 인해 빼앗기는 경우 (ex) time interrupt
  >- Blocked → Ready (Preemptive) : I/O 작업이 끝난 경우 (우선순위 기반 스케줄링에서는 ready로 가서 바로 cpu 권한 얻을 수 있음)
  >- Terminate (Non-preemptive)

- CPU 스케줄링 종류와 방법에는 대표적으로 어떤 것들이 있나요?  
  > - FCFS (First-Come First-Served)  
      - 먼저 온 프로세스에게 먼저 CPU를 할당해주는 비선점형 알고리즘
  > - SJF (Shortest-Job-First)  
      - CPU burst가 가장 짧은 프로세스에게 먼저 CPU를 할당해주는 알고리즘  
      - waiting time 최소화
  > - Priority Scheduling  
      - 우선순위(priority number)가 가장 높은 프로세스가 먼저 CPU를 할당받는 알고리즘  
      - Starvation이 일어날 수 있다. 
  > - RR (Round Robin)  
      - 각 프로세스에는 일정한 할당시간(time quantum)동안 CPU를 사용하고 할당 시간이 지나면 선점당하고 다시 ready queue로 들어가는 알고리즘이다.  
      - 응답 시간이 빠르다는 특징이 있다. 
  > - Multilevel Queue  
      - Ready queue를 여러 개로 분할하여 큐에 따라 스케줄링 방법을 다르게 하는 알고리즘  
      - 각 큐에 따라 CPU time을 적절한 비율로 할당한다. 
  > - Multilevel Feedback Queue  
      - Multilevel Queue에서 프로세스가 다른 큐로 이동 가능한 방법이다. 
      - CPU 사용 시간이 짧은 프로세스가 많이 할당받을 수 있다. 

- Starvation이란?  
  > Priority Scheduling 또는 SJF에서 발생하는 문제점으로 낮은 우선순위를 가진 프로세스가 계속 CPU 할당을 받지 못하는 현상이다. 

- Aging이란? 
  > Starvation 문제의 해결방안으로 우선순위가 낮은 프로세스가 계속 기다리면 우선 순위를 높여주는 방법이다.  

- Preemptive Scheduling과 Non-preemptive Scheduling의 차이점?  
  > - Preemptive Scheduling  
      - 현재 실행 중인 프로세스를 종료시키고 다른 프로세스가 CPUfmf 차지하는 방법이다. 대표적으로 Round Robin 알고리즘이 있다. 
  > - Non-preemptive Scheduling  
      - 프로세스가 한번 CPU를 차지하면 CPU burst가 완료될 때까지 CPU를 넘겨주지 않는 방법이다. 대표적으로 SJF 알고리즘이 있다.  

### ⚡️ Chapter 6. Process Synchronization

- 경쟁 상태(racing condition)란 무엇인가요?  
  > 여러 프로세스들이 동시에 공유 데이터에 접근하는 상황을 의미한다.

- 임계영역 문제에 대한 해결책에는 어떤 것들이 있나요?  
  > - Peterson's 알고리즘  
      - 임계영역 진입 상태를 저장하는 변수 (=flag)와 임계영역을 실행할 프로세스의 순서를 저장하는 변수 (=turn)을 이용하여 프로세스거 동시에 critical section에 접근할 수 없게 한다.     
  > - Semaphores  
      - 자원의 개수를 저장하는 변수 S와 공유 데이터를 획득하는 과정의 P연산, 공유 데이터를 반납하는 과정의 V연산을 이용하여 critical section에 들어가기 전에는 P연산, 나올 때는 V연산을 수행하여 프로세스거 동시에 critical section에 접근할 수 없게 한다.  

- 프로세스 혹은 스레드의 동기화란 무엇인가요?  
  > - 하나의 자원을 동시에 여러 개의 프로세스나 스레드가 접근하지 못하도록 제어하는 것

- thread-safe의 의미?  
  > 멀티 스레드 프로그래밍에서 어떤 함수나 변수 또는 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 의미함다. 

- 락을 걸지 않고 경쟁상태를 해결할 수 있는 방법은 무엇인가요?
  > Moniter를 이용하는 방법이다. Moniter는 공유 데이터에 접근하기 위해서는 모니터 내부의 procedure을 통해서만 접근할 수 있도록 하기 때문에 동일한 시간에 오직 하나의 프로세스나 스레드만 모니터에 들어갈 수 있게 한다. 

- 교착상태란 무엇이며, 교착상태가 발생하기 위해서는 어떤 조건이 있어야 하나요?

  > deadlock이란 일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태이다.  
  > deadlock의 발생 조건 4가지가 있다.  
  > 1. Mutual exclusion (상호 배제) : 동시에 하나의 프로세스만이 자원을 사용할 수 있다.  
  > 2. No preemption (비선점) : 프로세스는 자원을 스스로 release할 수 있고, 강제로 빼앗기지 않는다. 
  > 3. Hold and wait (보유 대기) : 자원을 가진 프로세스가 다른 자원을 기다릴 때 자신의 자원을 계속 보유하고 있다. 
  > 4. Circular wait (순환 대기) : 자원을 기다리는 프로세스들 사이에 사이클이 형성되어야 한다.

- 교착상태의 해결법은 무엇인가요?

  > 교착상태의 해결법은 크게 4가지로 나눌 수 있다.  
  > 1. Deadlock Prevention : deadlock을 예방하는 방법으로 자원 할당 시 deadlock의 조건 4가지 중 어느 하나를 만족하지 못하도록 한다.   
  > 2. Deadlock Avoidance : deadlock을 피하는 방법으로 자원 요청에 대한 부가적인 정보를 이용해서 deadlock의 가능성이 없는 경우에만 자원을 할당한다.  
  > 3. Deadlock Detection and Recovery : Deadlock이 발생을 감지하고 발견시 recover한다.    
  > 4. Deadlock Ignorance : 운영체제가 deadlock에 대해 책임을 지지 않는 방법으로 현재 대부분의 OS들이 채택하고 있는 방법이다.

- Banker's algorithm 은 무엇입니까?

  > Deadlock을 피하는 방법 중 자원의 인스턴스 수가 여러 개일 때 사용하는 알고리즘이다.추가 요청 가능한 인스턴스의 수(Need)가 이용 가능한 인스턴스의 수(Available)에 충분히 포함되는지를 확인하고 충족이 안된다면 충족이 가능한 프로세스에게 먼저 할당을 하면서 safe state를 유지하도록 한다. 

- 교착상태와 starvation의 차이는?

  > 프로세스 상태 차이  
  > - deadlock은 프로세스가 ready 상태에서 무한 대기를 하는 것이고, starvation은 프로세스가 asleep 상태에서 무한 대기를 하는 것이다.   
  > 필요한 자원 차이  
  > - deadlock은 필요한 공유 자원을 얻고자 하고, Starvation은 CPU를 할당받고자 한다.  
   
### ⚡️ Chapter 8. Memory Management

- 메모리 관리에서 페이징와 세그멘테이션에 대해서 설명해 보시오.

  > 페이징은 프로세스의 논리적 메모리를 일정한 크기의 페이지로 분할하여 물리적 메모리에 올리는 Noncontiguous한 메모리 할당 방법이다. 
  > 외부 단편화는 발생하지 않는다는 장점이 있지만 내부 단편화는 해결하지 못하고, page table을 저장하기 위한 메모리 공간이 더 필요하다는 단점이 있다.  

  > 세그멘테이션은 프로세스의 논리적 메모리를 의미 단위로 분할하여 물리적 메모리에 올리는 Noncontiguous한 메모리 할당 방법이다. 
  > 세그먼트마다 protection을 따로 수행할 수 있다는 장점이 있지만, 각각의 segment는 연속적으로 할당해야 한다는 단점이 있다.  

- First Fit, Best Fit, Worst Fit에 대해서 설명해 보시오.

  > Dynamic Storage-Allocation 문제로 가변 분할 방식에서 size가 N인 프로세스가 들어가기에 가장 적절한 hole을 찾는 방법을 3가지로 나눈 것이다.  
  > - First Fit : 처음 발견되는 N보다 큰 hole에 바로 할당한다.  
  > - Best-Fit : N보다 큰 hole을 다 탐색하고 그 중에 가장 작은 hole에 할당한다.   
  > - Worst-Fit : N보다 큰 hole을 다 탐색하고 그 중에 가장 큰 hole에 할당한다.   

- 외부 단편화란? 내부 단편화란?

  > 외부 단편화란 프로세스의 크기가 분할(partition)의 크기보다 큰 경우로 메모리에서 남은 총 공간을 계산했을 때 프로세스가 들어갈 공간이 있음에도 공간들의 크기가 작아서 아무 프로그램도 배정되지 않는 공간을 의미한다.  
  > 내부 단편화란 프로세스의 크기가 분할(partition)의 크기보다 작은 경우로 분할 내부에서 사용이 되지 않는 공간을 의미한다.  

  ### ⚡️ Chapter 9. Virtual Memory
- 가상 메모리(Virtual Memory)란?  

  > 가상 메모리(Virtual Memory)란, 물리 메모리 크기의 한계를 극복하기 위해 나온 메모리 관리 방법 중 하나로 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식을 의마한다. 가상 메모리는 프로세스를 실행할 때, 실행에 필요한 부분만 메모리에 올림으로써 물리 메모리의 용량보다 큰 프로세스를 수행할 수 있게 한다.  

- 가상 메모리를 사용할 시 장단점은?  

  > 장점  
  > - 프로그램의 크기가 물리 메모리보다 크더라도 실행이 가능하기 때문에 물리 메모리 크기의 제약으로부터 자유로워진다.  
  > - CPU 이용률이 증가한다.  
  > - 동시에 더 많은 프로그램을 수행할 수 있다.  
  >
  > 단점  
  > - 물리 메모리로 프로그램을 실행하는 것보다 속도가 느리다.    

- Demand Paging이란?  

  > Demand Paging이란, 프로세스를 구성하는 페이지가 실제로 필요로 할 떄 메모리에 올라는 것이다. 이를 통해 I/O 양과 물리적인 메모리 사용량이 감소하고, 메모리는 더 많은 프로그램을 수용 가능하게 되며 응답 시간 더 빨라진다. Damand Paging은 valid/invalid bit를 통해 page table에 해당 페이지가 있는지를 확인하고, valid인 경우 해당 메모리에 접근하여 값을 읽어오고, invalid인 경우 page fault를 발생시킨다. 

- page fault란?  

  > Demand paging에서 주소 변환 시 invalid bit라면 디스크에서 메모리로 해당 페이지를 가져오는 것이다. 
  > page fault의 처리 과정은 invalid한 page라면, 주소변환 하드웨어(MMU)가 trap을 발생시키고, CPU는 운영체제로 넘어가 page fault handler가 실행이 된다. page fault handler는 해당 페이지를 디스크에서 메모리로 올려준다. 

- 페이지 교체란?  
  
  > Paging replacement란, page fault 처리 과정에서 메모리에 free frame이 없는 경우에 다른 frame을 빼앗아야 하는 경우에, OS가 어떤 page을 쫓아내고 새로운 page를 올려놓을지 결정하는 것이다. 

- 페이지 교체 알고리즘의 종류와 각각의 특징에 대해 설명해 보시오.

  > OPT(Optimal Algorithm)  
  > - Optimal Algorithm은 가장 먼 미래에 참조된 page를 쫓아내는 알고리즘으로 가장 page fault가 적은 알고리즘이다. 항상 최적의 결과를 갖지만, 실제 시스템에서는 미래를 알 수 없기 때문에 살제 사용하기는 어려워 다른 알고리즘의 성능에 대한 upper bound를 제공한다.  

  > FIFO(First In First Out) Algorithm  
  > - FIFO Algorithm은 가장 오래 전에 참조된 page를 쫓아내는 알고리즘이다. 보통 메모리 크기를 늘려주면 보통 성능이 좋아지지만 이 알고리즘은 성능이 더 나빠질 수 있는 FIFO Anomaly 현상이 발생할 수 있다.  

  > LRU (Least Recently Used) Algorithm  
  > - LRU Algorithm은 가장 오래 전에 참조된 것을 지우는 알고리즘이다. 실제 메모리 관리 알고리즘에서 많이 사용하는 알고리즘이다. 연결 리스트로 LRU를 구현하면 page를 참조하고 지우는 데 시간복잡도는 O(1)이다.   

  > LFU(Least Frequently Used) Algorithm  
  > LFU Algorithm은 참조 횟수(reference count)가 가장 적은 page를 지우는 알고리즘이다. LRU 처럼 직전 참조 시점만 보는 것이 아니라 장기적인 시간 규모을 보기 때문에 page의 인기도를 좀 더 정확하게 반영할 수 있다. LFU는 Heap으로 구현하면 page를 참조하고 지우는데 시간복잡도는 O(log n)이다.  

  > Clock Algorithm  
  > - Clock Algorithm은 LRU의 근사(approximation) 알고리즘으로, reference bit를 사용해서 쫓아낼 페이지를 선정한다. 하드웨어가 페이지들을 참조할 때 reference bit를 1로 set하고, 운영체제가 쫓아낼 page를 결정할 때, 즉 page fault가 발생했을 때, reference bit를 보면서 1이라면 0으로 set하고, 0이면 해당 페이지를 쫓아낸다.   