# Operating System

### ⚡️ Chapter 1-2. Introduction & OS Stuructures

- 운영체제란 무엇인가?

  > 운영체제(Operating System)는 컴퓨터 하드웨어와 소프트웨어 자원을 관리하는 시스템 소프트웨어로 사용자와 하드웨어 사이의 중개 역할을 담당한다.

- 운영체제의 주요 목적은?

  > 운영체제는 1)컴퓨터 시스템 자원(CPU, Memory 등)을 효율적으로 관리하기 위한 목적과 2)컴퓨터 시스템을 사용자로 하여금 편리하게 사용하도록 지원하는 목적을 가진다.

- 커널이란 무엇인가?

  > 운영체제의 핵심으로 컴퓨터 자원들을 관리하는 역할을 담당한다.

- 부팅이 되는 과정은?

  > ① 컴퓨터 전원이 켜지면 (booting)
  > ② 컴퓨터 하드웨어 초기화
  > ③ 하드디스크로부터 메인메모리 첫 주소에 OS를 load
  > ④ OS 기동

- 시스템 콜에 대해 설명하세요

  > System Call은 운영체제의 커널이 제공하는 서비스를 이용하기 위해 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다.
  > 운영체제는 커널모드(Kernel Mode)와 사용자모드(User Mode)로 나뉘어 구동되는데, 시스템 콜은 이러한 커널 영역의 기능을 사용자 모드가 사용 가능하게, 즉 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해준다.

- 멀티 프로세싱과 멀티프로그래밍의 차이는?

  > 멀티프로세싱(Multi-processing) : 멀티 프로세싱은 다수의 프로세서(CPU)가 프로그램을 병렬적으로 처리하는 것을 의미한다.  
  > 멀티프로그래밍(Multi-programming) : CPU 효율을 높이기 위한 목적으로 메모리에 여러 개의 작업(프로그램)을 동시에 올리는 것을 의미한다.

- 메모리 계층 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오.
  > 레지스터 → 캐시 → 메인메모리 → 비휘발성메모리 → 하드디스크 드라이브 → 광학 디스크 → 자기 테이프

---

### ⚡️ Chapter 3. Processes

- Heap과 Stack의 차이점은 무엇인가요

  > 스택 영역은 정적 메모리가 저장되는 영역으로 LIFO 방식에 따라 동작하고, 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
  > 힙 영역은 동적 메모리가 저장되는 영역으로 사용자가 직접 관리해야 하는 메모리 영역이며, 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.

- 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요.

  > * text : 실행한 프로그램의 코드가 저장되는 영역
  > * data : 전역 변수와 정적(static) 변수가 저장되는 영역
  > * heap : 프로그램 런타임 중에 동적으로 할당된 메모리 영역
  > * stack : 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역

- 프로세스와 그 특징에 대해 설명하세요

  > 프로세스는 실행 중인 프로그램을 의미하며 os 작업의 단위이다.

- 프로세스가 종료되는 두 가지 조건은?

  > ?

- 인터럽트 발생 처리과정을 설명하세요.

  > 프로그램 실행 중 인터럽트가 발생하면 프로그램을 중단하고 현 프로그램 상태를 보관하기 위한 context switching 작업이 진행된다. Interruppt Vector를 읽어 ISR 주소값을 얻어 점프하고, 인터럽트 서비스 루틴을 처리한다. 해당 작업을 다 처리하면, 보관했던 레지스터를 복원한 후 인터럽트를 해제하고 이전 실행 위치로 PC 값이 복원된다.

- 인터럽트 기능이 없었다면 사용하는 방식에 대해 설명하세요.

  > 만약 인터럽트가 없다면 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 계속해서 체크를 해야하는데 이 과정을 폴링(Polling) 이라고 한다. 폴링이란 특정 주기마다 스레드를 돌면서 시그널이 들어왔는지 확인하는 방식으로, 시스템의 리소스를 많이 먹는 단점이 있으며 또한 특정 주기마다 확인하기 때문에 정확한 타이밍에 시그널이 들어왔는지 확인이 불가하며 주기에 따른 오차가 발생하는 문제가 있다.

- 프로세스의 생성 과정에 대해 설명해보세요.

  > PCB가 생성되며 OS가 실행한 프로그램의 코드를 읽어들여 프로세스에 할당된 메모리의 Text segment에 저장한다.  
  > 초기화된 전역 변수 및 static 변수를 data segment에 할당한다.  
  > HEAP과 Stack은 초기 메모리 주소만 초기화된다.  
  > PCB에 여러 정보가 기록되면 Ready Queue에서 CPU를 할당받기까지 대기한다.

- IPC의 통신 과정 설명하세요.

  > ?

- Context Switching이란 무엇인가요?

  > CPU가 어떤 프로세스를 실행하고 있는 상태에서 인터럽트에 의해 다음 우선 순위를 가진 프로세스가 실행되어야 할 때 기존의 프로세스 정보들은 PCB에 저장하고 다음 프로세스의 정보를 PCB에서 가져와 교체하는 작업을 컨텍스트 스위칭이라 한다.

- 동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?

  > ?

- 프로세스 제어블록에는 어떤 정보가 담겨있나요?
  
  > (1) Process ID : 프로세스를 구분하는 ID  
(2) Process State : 각 State 들의 상태를 저장한다.  
(3) Program Counter : 다음 Instruction 의 주소를 저장하는 카운터. CPU는 이 값을 통해 Process 의 Instruction 을 수행한다.  
(4) Register : Accumulator, CPU Register, General Register 등을 포함한다.  
(5) CPU Scheduling Information : 우선 순위, 최종 실행시간, CPU 점유시간 등이 포함된다.  
(6) Memory Information : 해당 프로세스 주소공간(lower bound ~ upper bound) 정보를 저장.  
(7) Process Information(페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등)  
(8) Device I/O Status(프로세스에 할당된 입출력 장치 목록, 열린 팔린 목록 등)  
(9) Pointer : 부모/자식 프로세스에 대한 포인터, 자원에 대한 포인터 등   
(10) Open File List : 프로세스를 위해 열려있는 파일의 리스트  

- child process, orphan process, zombie process에 대해 설명해 보시오.

  > - child process → 다른 프로세스에 의해 생성된 프로세스
  > - zombie process → 자식 프로세스가 종료되었는데, 부모 프로세스가 자식 프로세스가 반환한 정보를 회수하지 않으면 자식 프로세스는 종료되었음에도 정보가 메모리에 남아 있는 좀비 프로세스가 된다. 
  > - orphan process → 부모 프로세스가 자식 프로세스보다 먼저 종료되면 자식 프로세스는 고아 프로세스가 된다.
  
  ---

### ⚡️ Chapter 5. CPU Scheduling
 
- CPU 스케줄링이란 무엇인가요?  

  > 메인 메모리에서 실행 중인 프로세스에게 CPU를 효율적으로 할당하는 것을 의미한다.

- CPU Scheduling은 언제 발생하는가?  

  > CPU 스케줄링은 네 가지 상태에서 발생할 수 있다.
  > 1) **Running → Waiting(Blocked)** : I/O 요청이나 자식의 종료를 위해 wait( ) 함수 호출한 경우
  > 2) **Running → Ready** : 인터럽트가 발생한 경우
  > 3) **Waiting → Ready** : I/O 작업이 끝난 경우
  > 4) **Terminate**  
  > 이때, 비선점형 스케줄링은 1과 4의 경우일 때 스케줄링이 발생하지만, 선점형 스케줄링은 1,2,3,4 모두에서 발생 가능하다.

- CPU 스케줄링 종류와 방법에는 대표적으로 어떤 것들이 있나요?  

  > 1) **FCFS Scheduling**  
  >    - CPU에 먼저 도착하는 순서대로 프로세스를 할당해주는 방식으로, 비선점형 방식이며 Convoy Effect가 발생 가능하다는 문제가 있다.  
  > 2) **SJF(Shortest-Job-First) Scheduling**
  >    - 프로세스의 수행 시간이 짧은 순서대로 CPU에 할당하는 방식으로 선점형과 비선점형 두 방식이 존재한다. 이때 선점형 SJF 방식은 SRTF라 하며 최소의 평균 대기 시간(optimal)을 보장하지만, starvation 현상이 발생할 수 있다.  
  > 3) **Priority Scheduling**
  >    - 프로세스에게 우선순위를 부여해 우선순위가 높은 프로세스에게 CPU를 할당하는 방식이다. SJF도 일종의 우선순위 스케줄링이 되며, 이때도 기아 현상이 발생할 수 있는데 에이징(Aging) 기법으로 해결 가능하다.  
  > 4) **Round-Robin Scheduling**
  >     - 선점형 스케줄링 방식 중 하나로, 모든 프로세스가 같은 우선순위를 가지고 time slice(time quantum)를 기반으로 스케줄링한다. RR 스케줄링의 성능은 quantum 값에 따라 달라지는데, 해당 값이 너무 커지면 FCFS가 되고, 반대로 너무 작아지면 불필요한 context switching이 많이 발생해 효율이 떨어진다.  
  > 5) **Multilevel Queue**
  >     - 다단계 큐 스케줄링은 ready queue를 여러 개로 분할하고, 각 큐는 독립적인 스케줄링 알고리즘을 갖게 된다. queue들 사이의 스케줄링은 Fixed priority scheduling과 time slice 두 가지 방식이 존재한다.  
  > 6) **Multilevel Feedback Queue**
  >     - Multilevel Queue 방식에 프로세스가 다른 큐로 이동 가능하다는 조건이 추가된 스케줄링 알고리즘이다. aging을 이와 같은 방식으로 구현할 수 있다.  

- Starvation이란?  

  > 특정 프로세스의 우선 순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태를 의미한다. 예로, SJF 방식에서 수행시간이 긴 작업이 계속 뒤로 밀려나게 된다.

- Aging이란?  

  > 에이징 기법은 시간이 지날수록 오래 대기한 프로세스의 우선순위를 높이는 방식을 의미한다.

- Preemptive Scheduling과 Non-preemptive Scheduling의 차이점?  

  > Non-preemptive Scheduling은 프로세스가 block(wait) 상태로 바뀌거나 실행이 끝났을 때만 다른 프로세스로 교체 가능하지만, Preemptive Scheduling은 프로세스 실행 중에 이를 중단시키고 다른 프로세스로 교체할 수 있다. 이때, Non-preemptive Scheduling은 Preemptive Scheduling과 달리 지연되는 경우가 있어 응답시간이 평균적으로 길다. 
  
  ---
  
### ⚡️ Chapter 6. Process Synchronization

- 경쟁 상태(racing condition)란 무엇인가요? 

  > Race condition은 Multi-processor system에서 두 개 이상의 프로세스나 스레드가 동시에 공유 데이터에 접근하는 상황을 의미한다. 공유 데이터의 동시 접근은 데이터의 불일치 문제를 발생시킬 수 있다.  

- 임계영역 문제에 대한 해결책에는 어떤 것들이 있나요?  

  > 먼저, 임계영역 문제를 해결하기 위한 조건에는 Mutual exclusion(상호 배제), Progress(진행), Bounded waiting(한정된 대기) 3가지가 있다. 이를 만족하는 구체적인 해결법으로는 Mutex와 Semaphore가 있다.  
  > - **Mutex**는 Lock과 Unlock을 이용하는 방식으로, 특정 프로세스가 공유자원을 사용하고 있을 경우, 다른 프로세스가 해당 공유 자원을 사용하지 못하게 제어하는 기법을 말한다. 동시에 공유 자원에 접근하는 것을 막기 위해 critical section에 진입하는 프로세스는 lock을 획득하고 critical section을 빠져나올 때, lock을 방출함으로써 동시에 접근이 되지 않도록 한다.  
  > - **Semaphore**는 counter를 두어서 동시에 리소스에 접근할 수 있는 허용 가능한 스레드 수를 제어하는 카운팅 세마포어(Counting semaphore) 방식과 0과 1 값만 사용하는 이진 세마포어(Binary semaphore, Mutex) 방식이 있다. 이때, 세마포어의 대기는 while문으로 돌기 때문에 Critical Section 진입을 기다리면서 계속 CPU와 메모리를 사용하는 Busy waiting(=spin lock)의 문제가 있다. 이를 대체하기 위한 방법으로 **Block & Wakeup**(=sleep lock)이 있으며, 이는 Critical Section으로의 진입에 실패한 프로세스를 기다리게 하지 않고 Block 시킨 뒤 Critical Section에 자리가 나면 다시 깨워줌으로써 Busy waiting에서의 CPU 낭비 문제를 해결해준다.  

- 프로세스 혹은 스레드의 동기화란 무엇인가요?  

  > 공유되고 있는 변수를 사용해 한 프로세스(스레드)가 작업을 하고 있을 때, 다른 프로세스(스레드)가 그 변수 이용이 끝나기 전까지 사용하는 것을 막아주는 것을 의미한다. 즉, 상호 배제의 한 방법이다.  

- thread-safe의 의미?  

  > 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 무리가 없음을 의미한다. Thread-safe하게 구현하기 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어해줘야 한다(상호배제).  

- 락을 걸지 않고 경쟁상태를 해결할 수 있는 방법은 무엇인가요?

  > 모니터(Monitor)는 세마포어와 달리 Lock을 걸 필요가 없다. 세마포어는 프로그래머가 직접 wait와 signal을 사용하여 race condition을 해결해야 하지만, 모니터는 자체적인 기능으로 해결할 수 있게 된다.   

---
  
### ⚡️ Chapter 7. Deadlocks

- 교착상태란 무엇이며, 교착상태가 발생하기 위해서는 어떤 조건이 있어야 하나요?

  > 교착상태(Deadlock)란 일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태로, 결과적으로 아무것도 완료되지 못하는 상태를 의미한다. 이러한 교착상태는 4가지 조건에 의해 발생한다.  
  > **1. Mutual exclusion (상호 배제)**  
  > 매 순간 하나의 프로세스만이 자원을 사용할 수 있음  
  > **2. No preemption (비선점)**  
  > 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음  
  > **3. Hold and wait (보유대기)**  
  > 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음  
  > **4. Circular wait (순환대기)**  
  > 자원을 기다리는 프로세스 간에 사이클이 형성되어야 함  

- 교착상태의 해결법은 무엇인가요?

  > 교착 상태의 처리는 크게 네 가지 방법으로 가능하다.  
  > **1. Deadlock Prevention**  
  > Deadlock이 발생하지 않도록 미리 예방하는 것으로, 자원 할당 시 Deadlock의 4가지 필요조건 중 어느 하나가 만족되지 않도록 하는 방식이다.  
  > **2. Deadlock Avoidance**  
  > 자원 요청에 대한 부가적인 정보를 이용해서 deadlock의 가능성이 없는 경우에만 자원을 할당한다. 시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원을 할당한다. 각 자원 타입마다 하나의 인스턴스가 존재하는 경우는 자원 할당 그래프 알고리즘을, 여러 인스턴스가 존재하는 경우는 은행원 알고리즘을 이용할 수 있다.  
  > **3. Deadlock Detection and recovery**  
  > Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발견 시 recover하는 방법이다.  
  > **4. Deadlock Ignorance**  
  > Deadlock을 시스템이 책임지지 않는 방식이다. 따라서 만약 시스템에 Deadlock이 발생한 경우, 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 프로세스를 죽이는 등의 방법으로 대처한다. UNIX를 포함한 대부분의 OS가 해당 방식을 채택하고 있다.  

- Banker's algorithm 은 무엇입니까?

  > Deadlock이 발생할 때, 이를 회피하는 목적으로 프로세스가 자원을 요청할 때 safe 상태를 유지하는 경우에만 할당해준다. 즉, 총 요청 자원의 수가 남은 자원의 수보다 적은 프로세스만 선택하여 수행한다. 만일 그런 프로세스가 없다면 unsafe 상태인 것이다. 할당받은 프로세스가 종료되면 모든 자원을 반납하고, 모든 프로세스가 종료될 때까지 이 과정을 반복한다.

- 교착상태와 starvation의 차이는?

  > 교착상태는 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말하고 기아 상태는 프로세스가 원하는 자원을 계속 할당 받지 못하는 상태를 의미한다. 즉 교착 상태는 여러 프로세스가 동일한 자원 점유를 원할 때 발생하고 기아 상태는 여러 프로세스가 자원을 점유하기 위해 경쟁 할 때 특정 프로세스는 영원히 자원 할당을 받지 못하는 것이다. 
