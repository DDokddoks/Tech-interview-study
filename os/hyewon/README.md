# Operating System

### ⚡️ Chapter 1-2. Introduction & OS Stuructures

- 운영체제란 무엇인가?

  > 운영체제(Operating System)는 컴퓨터 하드웨어와 소프트웨어 자원을 관리하는 시스템 소프트웨어로 사용자와 하드웨어 사이의 중개 역할을 담당한다.

- 운영체제의 주요 목적은?

  > 운영체제는 1)컴퓨터 시스템 자원(CPU, Memory 등)을 효율적으로 관리하기 위한 목적과 2)컴퓨터 시스템을 사용자로 하여금 편리하게 사용하도록 지원하는 목적을 가진다.

- 커널이란 무엇인가?

  > 운영체제의 핵심으로 컴퓨터 자원들을 관리하는 역할을 담당한다.

- 부팅이 되는 과정은?

  > ① 컴퓨터 전원이 켜지면 (booting)
  > ② 컴퓨터 하드웨어 초기화
  > ③ 하드디스크로부터 메인메모리 첫 주소에 OS를 load
  > ④ OS 기동

- 시스템 콜에 대해 설명하세요

  > System Call은 운영체제의 커널이 제공하는 서비스를 이용하기 위해 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다.
  > 운영체제는 커널모드(Kernel Mode)와 사용자모드(User Mode)로 나뉘어 구동되는데, 시스템 콜은 이러한 커널 영역의 기능을 사용자 모드가 사용 가능하게, 즉 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해준다.

- 멀티 프로세싱과 멀티프로그래밍의 차이는?

  > 멀티프로세싱(Multi-processing) : 멀티 프로세싱은 다수의 프로세서(CPU)가 프로그램을 병렬적으로 처리하는 것을 의미한다.  
  > 멀티프로그래밍(Multi-programming) : CPU 효율을 높이기 위한 목적으로 메모리에 여러 개의 작업(프로그램)을 동시에 올리는 것을 의미한다.

- 메모리 계층 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오.
  > 레지스터 → 캐시 → 메인메모리 → 비휘발성메모리 → 하드디스크 드라이브 → 광학 디스크 → 자기 테이프



### ⚡️ Chapter 3. Processes

- Heap과 Stack의 차이점은 무엇인가요

  > 스택 영역은 정적 메모리가 저장되는 영역으로 LIFO 방식에 따라 동작하고, 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
  > 힙 영역은 동적 메모리가 저장되는 영역으로 사용자가 직접 관리해야 하는 메모리 영역이며, 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.

- 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요.

  > * text : 실행한 프로그램의 코드가 저장되는 영역
  > * data : 전역 변수와 정적(static) 변수가 저장되는 영역
  > * heap : 프로그램 런타임 중에 동적으로 할당된 메모리 영역
  > * stack : 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역

- 프로세스와 그 특징에 대해 설명하세요

  > 프로세스는 실행 중인 프로그램을 의미하며 os 작업의 단위이다.

- 프로세스가 종료되는 두 가지 조건은?

  > ?

- 인터럽트 발생 처리과정을 설명하세요.

  > 프로그램 실행 중 인터럽트가 발생하면 프로그램을 중단하고 현 프로그램 상태를 보관하기 위한 context switching 작업이 진행된다. Interruppt Vector를 읽어 ISR 주소값을 얻어 점프하고, 인터럽트 서비스 루틴을 처리한다. 해당 작업을 다 처리하면, 보관했던 레지스터를 복원한 후 인터럽트를 해제하고 이전 실행 위치로 PC 값이 복원된다.

- 인터럽트 기능이 없었다면 사용하는 방식에 대해 설명하세요.

  > 만약 인터럽트가 없다면 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 계속해서 체크를 해야하는데 이 과정을 폴링(Polling) 이라고 한다. 폴링이란 특정 주기마다 스레드를 돌면서 시그널이 들어왔는지 확인하는 방식으로, 시스템의 리소스를 많이 먹는 단점이 있으며 또한 특정 주기마다 확인하기 때문에 정확한 타이밍에 시그널이 들어왔는지 확인이 불가하며 주기에 따른 오차가 발생하는 문제가 있다.

- 프로세스의 생성 과정에 대해 설명해보세요.

  > PCB가 생성되며 OS가 실행한 프로그램의 코드를 읽어들여 프로세스에 할당된 메모리의 Text segment에 저장한다.  
  > 초기화된 전역 변수 및 static 변수를 data segment에 할당한다.  
  > HEAP과 Stack은 초기 메모리 주소만 초기화된다.  
  > PCB에 여러 정보가 기록되면 Ready Queue에서 CPU를 할당받기까지 대기한다.

- IPC의 통신 과정 설명하세요.

  > ?

- Context Switching이란 무엇인가요?

  > CPU가 어떤 프로세스를 실행하고 있는 상태에서 인터럽트에 의해 다음 우선 순위를 가진 프로세스가 실행되어야 할 때 기존의 프로세스 정보들은 PCB에 저장하고 다음 프로세스의 정보를 PCB에서 가져와 교체하는 작업을 컨텍스트 스위칭이라 한다.

- 동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?

  > ?

- 프로세스 제어블록에는 어떤 정보가 담겨있나요?
  
  > (1) Process ID : 프로세스를 구분하는 ID  
(2) Process State : 각 State 들의 상태를 저장한다.  
(3) Program Counter : 다음 Instruction 의 주소를 저장하는 카운터. CPU는 이 값을 통해 Process 의 Instruction 을 수행한다.  
(4) Register : Accumulator, CPU Register, General Register 등을 포함한다.  
(5) CPU Scheduling Information : 우선 순위, 최종 실행시간, CPU 점유시간 등이 포함된다.  
(6) Memory Information : 해당 프로세스 주소공간(lower bound ~ upper bound) 정보를 저장.  
(7) Process Information(페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등)  
(8) Device I/O Status(프로세스에 할당된 입출력 장치 목록, 열린 팔린 목록 등)  
(9) Pointer : 부모/자식 프로세스에 대한 포인터, 자원에 대한 포인터 등   
(10) Open File List : 프로세스를 위해 열려있는 파일의 리스트  

- child process, orphan process, zombie process에 대해 설명해 보시오.

  > - child process → 다른 프로세스에 의해 생성된 프로세스
  > - zombie process → 자식 프로세스가 종료되었는데, 부모 프로세스가 자식 프로세스가 반환한 정보를 회수하지 않으면 자식 프로세스는 종료되었음에도 정보가 메모리에 남아 있는 좀비 프로세스가 된다. 
  > - orphan process → 부모 프로세스가 자식 프로세스보다 먼저 종료되면 자식 프로세스는 고아 프로세스가 된다.

