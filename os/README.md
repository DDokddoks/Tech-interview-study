# Operating System

### ⚡️ Chapter 1-2. Introduction & OS Stuructures

- 운영체제란 무엇인가?

  > 운영체제(Operating System)는 컴퓨터 시스템(하드웨어)을 운영 및 관리하는 항상 실행 중인 시스템 소프트웨어(프로그램)이다. 응용 프로그램을 위한 기반(system service)을 제공하며 프로세스 및 자원을 관리하고, 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 하면서 사용자가 하드웨어를 직접 조작하는 것을 방지한다. 

- 운영체제의 주요 목적은?

  > 운영체제는 컴퓨터 시스템 자원(CPU, Memory 등)을 효율적으로 관리해 **시스템 효율성**을 높이는 목적과 컴퓨터 시스템을 사용자로 하여금 편리하게 사용하도록 지원하는 **사용자 편의성**의 목적을 가진다.

- 커널이란 무엇인가?

  > 운영체제의 핵심으로 항상 메모리에 상주하는 운영체제의 부분을 커널이라고 한다.

- 부팅이 되는 과정은?

  > 1. 컴퓨터의 전원이 켜지면 Boot-ROM에 저장되어 있는 Bootstrap Program이 실행  
  > 2. 컴퓨터 시스템 하드웨어 초기화  
  > 3. HDD에서 OS 프로그램을 MM의 첫번째 자리에 로드하여 OS 실행  
  > 4. 운영체제 프로그램 실행 시작

- 시스템 콜에 대해 설명하세요

  > System Call은 운영체제의 커널이 제공하는 서비스를 이용하기 위해 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다. 운영체제는 커널모드(Kernel Mode)와 사용자모드(User Mode)로 나뉘어 구동되는데, 시스템 콜은 이러한 커널 영역의 기능을 사용자 모드가 사용 가능하게 한다.

- 멀티프로세싱 vs 멀티프로그래밍 vs 멀티태스킹 vs 멀티쓰레딩

  > * 멀티 프로세싱(Multi-processing) : 다수의 프로세서(CPU)가 다수의 프로세스를 서로 병렬적으로 처리하는 것, **프로그램을 더 빨리 처리하기 위함**이 목적
  > * 멀티 프로그래밍(Multi-programming) : 단일 프로세서(CPU)가 다수의 프로세스가 동시에 처리하는 것, **CPU의 활용도를 최대화**하기 위함이 목적
  > * 멀티 태스킹(Multi-tasking) : 다수의 작업(task)을 운영체제 스케줄링에 의해 번갈아가면서 처리하는 것, 사용자에게 **다수의 작업이 동시에 처리되는 것처럼 느끼게** 할 수 있다.
  > * 멀티 쓰레딩(Multi-threading) : 다수의 스레드가 하나의 프로세스를 구성하여 서로 자원을 공유하는 것, **자원을 효율적으로 사용하여 작업 처리 속도를 향상**시키는 것

- 메모리 계층 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오.

  > <img src="https://user-images.githubusercontent.com/68578916/175803000-38af3f0d-8ddb-4a29-8aa7-78fa3ccb33a9.png" width="500" />


### ⚡️ Chapter 3. Processes

- Heap과 Stack의 차이점은 무엇인가요?

  > Heap
  >  * 동적 메모리가 저장되는 영역
  >  * 사용자가 직접 관리할 수 있고, '그리고 관리를 해야만 하는' 메모리 영역이다.
  >  * 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.  
  >  
  >  Stack
  >  * 정적 메모리가 저장되는 영역
  >  * 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다.
  >  * 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.

- 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요.

  > * __Text__ : Code 혹은 Instruction 영역이라고도 하며, 컴파일된 프로그램 코드가 저장되어 있다. 고정 크기이다.
  > * __Data__ : 전역 변수를 저장하고 있는 영역이다. 고정 크기이다.
  > * __Heap__ : 프로그램의 런타임 중에 동적으로 할당되는 메모리가 저장되는 영역이다. 가변 크기이다.
  > * __Stack__ : 함수 호출 시 함수 파라미터, return 주소, 지역 변수 등 임시 데이터의 저장장소이다. 가변 크기이다.

- 프로세스와 그 특징에 대해 설명하세요.

  > 프로세스는 실행 중인 프로그램으로 운영체제에서 작업의 단위이다.     
  > 프로세스는 4가지의 영역(text, stack, data, heap)으로 구분된다.   
  > 프로세스는 5가지 상태 (New, Running, Waiting, Ready, Terminated) 를 가진다.
  > 각 프로세스의 정보는 PCB에 저장된다.  

- 프로세스가 종료되는 2가지 경우를 설명하세요.

  > 프로세스가 마지막 명령을 수행하거나 exit() 시스템 콜을 호출하였을 때 스스로 종료한다.  
  > 프로세스가 다른 프로세스를 종료시키는 경우에 부모가 자식들 중 하나의 실행을 종료할 수 있다.  
  >  * 경우1. 자식이 자신에게 할당된 자원을 초과하여 사용할 때  
  >  * 경우2. 자식에게 할당된 태스크가 더 이상 필요없을 때  
  >  * 경우3. 부모가 exit를 하는데, 운영체제는 부모가 exit한 후에 자식이 실행을 계속하는 것을 허용하지 않는경우. (cascading termination(연쇄식 종료))  

- 인터럽트 발생 및 처리과정을 설명하세요.

  > 프로그램 실행 중 인터럽트가 발생하면 프로그램을 중단하고 현 프로그램 상태를 보관하기 위한 context switching 작업이 진행된다. 그 후 인터럽트 번호를 읽고 해당 번호를 인터럽트 벡터의 인덱스로 사용하여 ISR 주소값으로 점프하고, 인터럽트 서비스 루틴을 처리한다. 해당 작업을 다 처리하면, 보관했던 레지스터를 복원한 후 인터럽트를 해제하고 이전 실행 위치로 PC 값이 복원된다.

- 인터럽트 기능이 없다면 사용하는 방식에 대해 설명하세요.

  > 인터럽트 기능이 없다면 CPU는 어떤 일을 할 시기를 알기 위해 디바이스 상태를 계속 체크해야 하며, 이를 **폴링(Polling)** 이라고 한다.인터럽트 방식에 비해 구현이 간편하다는 장점이 있지만 다른 프로그램이나 장치들 간의 폴링이 많아질수록 CPU 사용량이 늘어나 성능이 크게 떨어지게 되며, 폴링의 주기가 길어질수록 반응 속도가 늦어져 실시간성이 떨어진다는 단점이 있다. 

- 프로세스의 생성 과정에 대해 설명해보세요.

  > 1. 생성된 새로운 프로세스에 프로세스 id를 할당한다.  
  > 2. 프로세스의 모든 구성 요소를 포함할 수 있는 주소 공간과 PCB 공간을 할당한다.  
  > 3. PCB를 초기화한다. 프로그램의 코드는 Text 영역, 초기화된 전역/static 변수는 Data 영역에 저장되며 Heap과 Stack 영역은 초기 메모리 주소만 초기화된다. 그 외에 프로세스의 상태 정보, 프로그램 카운터, 우선순위 등이 초기화된다.
  > 4. PCB에 여러 정보가 기록되면 Ready Queue에서 CPU를 할당받기를 대기한다. 

- IPC 방식에 대해 설명하세요.

  > IPC의 방식에는 Shared Memory 방식과 Message Passing 방식 두 가지가 있다.  
  > **Shared Memory** 방식은 둘 이상의 프로세스가 공유하는 메모리 영역을 두고 해당 메모리 영역에 데이터를 채우거나 소비하는 등 변경하는 데이터를 공유하는 방식으로 통신한다.  
  > **Message Passing** 방식은 프로세스 간의 메시지를 주고 받는 방식으로 (send, receive) 이때 커널이 메시지를 전달해주며 관리한다. 크게 direct, indrect 통신으로 구분된다.
  > * direct 통신은 수신인과 발신인을 명시하고 소통하는 두 프로세스 사이에 자동으로 하나의 링크가 생성된다.
  > * indirect 통신은 수신인과 발신인을 명시하지 않아도 되고, 메시지들을 mailbox나 port를 통해서 주고 받는다. 각 프로세스가 공유 mailbox를 가지고 있는 경우 링크가 생성되고, 링크는 2개 이상의 프로세스와 연결될 수 있다.

- Context Switching이란 무엇인가요?

  > 어떤 프로세스를 실행하고 있는 상태에서 인터럽트에 의해 다른 프로세스가 실행되어야 할 때, 기존의 프로세스 정보들은 PCB에 저장하고 다음 프로세스의 정보를 PCB에서 가져와 교체하는 작업을 컨텍스트 스위칭이라 한다.

- 동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?

  > 동기와 비동기는 프로세스의 수행 순서 보장에 대한 매커니즘이고 블록킹과 논블록킹은 프로세스의 유휴 상태에 대한 개념으로 완전한 별개의 개념이라는 것이다.  
  > - 동기 & 비동기    
  >   - 처리해야 할 작업들을 어떠한 '흐름'으로 처리 할 것인가에 대한 관점  
  >   - 즉, 호출되는 함수의 작업 완료 여부를 신경쓰냐에 따라, 함수 실행/리턴 순차적인 흐름을 따르느냐, 안따르느냐 관심사  
  >    - 동기   
  >        - 호출하는 함수 A가 호출되는 함수 B의 작업 완료 후 리턴을 기다리거나, 바로 리턴 받더라도 미완료 상태이라면 작업 완료 여부를 스스로 계속 확인하며 신경쓰면 Synchronous (작업을 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작)  
  >    - 비동기  
  >      - 함수 A가 함수 B를 호출할 때 콜백 함수를 함께 전달해서, 함수 B의 작업이 완료되면 함께 보낸 콜백 함수를 실행한다.
  >      - 함수 A는 함수 B를 호출한 후로 함수 B의 작업 완료 여부에는 신경쓰지 않는다. Asynchronous (시작, 종료가 일치하지 않으며, 끝나는 동시에 시작을 하지 않음)
  >  - 블로킹 & 논블로킹
  >     - 처리되어야 하는 (하나의) 작업이, 전체적인 작업 '흐름'을 막느냐 안막느냐에 대한 관점
  >     - 즉, 제어권이 누구한테 있느냐가 관심사
  >      - Blocking
  >         - A 함수가 B 함수를 호출하면, 제어권을 A가 호출한 B 함수에 넘겨준다. (자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것)
  >      - Non-Blocking
  >         - A 함수가 B 함수를 호출해도 제어권은 그대로 자신이 가지고 있는다. (다른 주체의 작업에 관련없이 자신의 작업을 하는 것)

- 프로세스 제어블록에는 어떤 정보가 담겨있나요?

    > (1) Process ID : 프로세스를 구분하는 ID  
(2) Process State : 각 State 들의 상태를 저장한다.  
(3) Program Counter : 다음 Instruction 의 주소를 저장하는 카운터. CPU는 이 값을 통해 Process 의 Instruction 을 수행한다.  
(4) Register : Accumulator, CPU Register, General Register 등을 포함한다.  
(5) CPU Scheduling Information : 우선 순위, 최종 실행시간, CPU 점유시간 등이 포함된다.  
(6) Memory Information : 해당 프로세스 주소공간(lower bound ~ upper bound) 정보를 저장.  
(7) Process Information(페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등)  
(8) Device I/O Status(프로세스에 할당된 입출력 장치 목록, 열린 팔린 목록 등)  
(9) Pointer : 부모/자식 프로세스에 대한 포인터, 자원에 대한 포인터 등   
(10) Open File List : 프로세스를 위해 열려있는 파일의 리스트  


- child process, orphan process, zombie process에 대해 설명해 보시오.

  > **child process** : 부모 프로세스가 fork() 시스템 콜을 호출하면서 만들어진 프로세스로 부모의 프로세스의 복제 프로세스이다.  
  > **orphan process** : parent process가 wait()을 호출하지 않고 자식 프로세스보다 먼저 종료해버린 경우에 child process가 완전히 종료되지 못하고 남아있게 되는데 이때 child process를 orphan process라고 한다.  
  > **zombie process** : 자신은 종료되었지만, parent process가 아직 wait()를 호출하지 않은 상태일 때의 child process를 의미한다. 모든 프로세스는 아주 짧은 시간이나마 zombie process 상태를 머무르게 된다. zombie process를 활용하여 daemon process(background process)를 만들 때 쓰이기도 한다.

### ⚡️ Chapter 4. Thread

- 프로세스와 쓰레드의 차이를 설명해보세요

  > 프로세스는 운영체제로부터 할당받는 작업의 단위(실행 중인 프로그램)이고, 스레드는 할당 받은 자원을 이용하는 실행 단위이다. 프로세스는 독립적인 메모리 영역을 할당받지만 스레드는 스택을 제외한 나머지 공간을 공유한다.

- 크롬 탭이 프로세스인지 쓰레드인지 설명해보세요

  > 크롬은 탭마다 PID를 가지고 있으니 Process이며 각 Tab마다 랜더링 정보나 기타 데이터를 따로 관리한다. 이로 인해 메모리를 많이 잡아먹기도 하지만 하나의 Tab에 오류가 생겼다고 모든 Tab에 영향을 끼치진 않는다.

- 멀티 프로세스와 멀티 스레드 각각의 장단점

  > - 멀티 프로세스
  >   - 장점  
  >     • 각 프로세스가 독립된 영역(code, data, stack, heap)을 갖고 있기 때문에 여러 자식 프로세스 중 하나에 문제가 발생해도 해당 프로세스에만 영향을 미친다.  
• 메모리 침범 문제를 OS 차원에서 해결하므로 안전하다.  
  >   - 단점  
  >      • 작업량이 많아지면 context switching 시 오버헤드가 발생한다.  
          • 프로세스 간의 복잡한 통신(IPC)가 필요하다.  
  > - 멀티 스레드
  >   - 장점  
  >     • 메모리 공간, 시스템 자원의 효율성이 증가한다.  
• context switching 시 교환해야 할 대상이 적으므로 비용이 적다.  
• data, heap 영역을 이용해 데이터를 주고 받으므로 스레드 간 통신이 간단하다.  
  >   - 단점  
  >     • 서로 다른 스레드가 Stack을 제외한 메모리 공간을 공유하기 때문에 동기화 문제가 발생할 수 있다.  
• 스레드 간의 자원 공유는 전역 변수(data segment)를 이용하므로 다른 스레드가 동시에 사용할 때 충돌이 발생할 수 있다.  
• 하나의 스레드에 문제가 생기면 전체 스레드가 영향을 받는다.  
• 주의 깊은 설계가 필요하며 디버깅이 까다롭다.  
• 멀티 스레드의 단점은 critical section 기법을 통해 대비할 수 있다.  

- 멀티 프로세스 대신 멀티 스레드를 사용하는 이유는 무엇입니까?

  > - Responsiveness(응답성)
  >    - 프로세스의 일부가 block 되어도, 지속적인 실행이 가능함
  >  - Resource Sharing(자원 공유)
  >    - 프로세스의 자원을 공유하여 shared memory와 message passing보다 용이
  >  - Economy(경제)
  >    - 프로세스 생성보다 효율적
  >    - 스레드 스위칭이 context switching보다 오버헤드가 적음
  >  - Scalability(확장성)
  >     - 각 프로세스들을 thread 단위로 분할하여 실행함으로써 multiprocessor 구조에서 더 큰 이점을 얻을 수 있음

- 사용자 수준의 스레드와 커널 수준의 스레드의 차이는 무엇인가요?

  > - **User threads**
  >   - user mode에서 사용되는 thread  
  >   - kernel 위에서 kernel support 없이 관리  
  >   - OS가 가진 CPU들을 자유롭게 사용할 수는 없음  
  > - **kernel threads**
  >   - kernel mode에서 사용되는 thread  
  >   - OS가 직접 관리 및 지원  
  >   - OS가 가진 CPU들을 자유롭게 사용할 수 있음  

- 스레드 풀링이란 무엇이고 장점은?

  > - Thread Pools
  >   - 프로세스를 시작할 때 아예 일정한 수의 thread들을 미리 풀로 만들어 두는 것  
  >   - 매번 사용되고 바로 폐기되는 스레드를 새로 생성하는 것은 시간 낭비  
  >   - 개수의 한계 없이 모든 요청에서 새 스레드를 생성하면 CPU 시간, 메모리 공간 등 자원이 고갈될 수 있기 때문  
  > - 장점
  >   - 새 스레드를 만들어 주기보다 기존 스레드로 서비스해 주는 것이 종종 더 빠르다.  
  >   - 스레드 풀은 임의 시각에 존재할 스레드 개수에 제한을 둔다. 이러한 제한은 많은 수의 스레드를 병렬 처리할 수 없는 시스템에 도움이 된다.  
  >   - 태스크를 생성하는 방법을 태스크로부터 분리하면 태스크를 실행을 다르게 할 수 있다. 예를 들어 태스크를 일정 시간 후에 실행되도록 스케줄 하거나 혹은 주기적으로 실행시킬 수 있다.  
  
### ⚡️ Chapter 5. CPU Scheduling
 
- CPU 스케줄링이란 무엇인가요?  

- CPU Scheduling은 언제 발생하는가?  

- CPU 스케줄링 종류와 방법에는 대표적으로 어떤 것들이 있나요?  

- Starvation이란?  

- Aging이란?  

- Preemptive Scheduling과 Non-preemptive Scheduling의 차이점?  

